# 从0开始学架构

# 开篇词（1讲）

### 开篇词

* 架构设计相关的特性
* 本课程的内容

## 基础架构（13讲）

### 1.架构到底是指什么？

* 系统与子系统

* 模块与组件

* 框架和架构

  ---

* 关于以上三个概念的总结：

  * 架构是顶层设计；框架是面向编程或配置的半成品；组件是从技术维度上的复用；模块是从业务维度上职责的划分；系统是相互协同可运行的实体。

  * 系统与子系统：系统是由一系列有关联，按特定规则组成的个体，并且产生新的能力，而系统与子系统则是观察的交角度不同

    模块与组件：模块是从逻辑角度去看待，而组件是从物理角度去看待

    框架与架构：框架是规范也是约束，可以理解为封闭性的话题，定义好，让别人如何去使用，而架构是一种结构，是一种开放性的话题，如何去设计组织架构，如何让架构更具有拓展性，减少沟通错误成本

  * 关于系统：
    系统和子系统其实都是系统，只不过在本业务里边的分层不同，只有顶层为系统，其他都为子系统，就像目录树一样，看你目录最深有多少层。

    模块向虚(逻辑)，组件向实(代码)。

    框架向虚(规范)，架构向实(结构)。

  * 做**架构**就是对于解决一个或者一类**问题**，构建一个**系统**，你需要为这个**系统**根据业务划分**模块**，需要加入能组合起来的**组件**和**框架**，然后你需要构建一系列**规则**，让这些**组件**和**框架跑**起来，各自发挥各自的能力，来实现一个个**模块**，然后这些**模块**又组合起来成了整个**系**统，所以做架构需要很熟悉业务，会业务逻辑划分，要熟悉很多**框架**，**组件**，知道他们的能力，熟悉怎么组合他们完美的运作起来！

    问题，模块，规则，系统，是架构四要素

### 2.架构设计的历史背景

这篇文章表面上看实在回顾历史，实则是启发大家为什么要有架构设计？什么是架构设计？有没有最好的架构设计？好的架构设计应当具备什么？

评论：

*   在古代的狼人传说中，只有用银质子弹（银弹）才能制服这些异常凶残的怪兽。在软件开发活动中，“银弹”特指人们渴望找到用于制服软件项目这头难缠的“怪兽”的“万能钥匙”。

  软件开发过程包括了分析、设计、实现、测试、验证、部署、运维等多个环节。从IT技术的发展历程来看，先辈们在上述不同的环节中提出过很多在当时看来很先进的方法与理念。但是，这些方法、理念在摩尔定律、业务创新、技术发展面前都被一一验证了以下观点：我们可以通过诸多方式去接近“银弹”，但很遗憾，软件活动中没有“银弹”。

  布鲁克斯发表《人月神话》三十年后，又写了《设计原本》。他认为一个成功的软件项目的最重要因素就是设计，架构师、设计师需要在业务需求和IT技术中寻找到一个平衡点。个人觉得，对这个平衡点的把握，就是架构设计中的取舍问题。而这种决策大部分是靠技术，但是一定程度上也依赖于架构师的“艺术”，技术可以依靠新工具、方法论、管理模式去提升，但是“艺术”无法量化 ，是一种权衡。

  软件设计过程中，模块、对象、组件本质上是对一定规模软件在不同粒度和层次上的“拆分”方法论，软件架构是一种对软件的“组织”方法论。一分一合，其目的是为了软件研发过程中的成本、进度、质量得到有效控制。但是，一个成功的软件设计是要适应并满足业务需求，同时不断“演化”的。设计需要根据业务的变化、技术的发展不断进行“演进”，  这就决定了这是一个动态活动，出现新问题，解决新问题，没有所谓的“一招鲜”。

  以上只是针对设计领域的银弹讨论，放眼到软件全生命周期，银弹问题会更加突出。

  小到一个软件开发团队，大到一个行业，没有银弹，但是“行业最佳实践”可以作为指路明灯，这个可以有。   

* 我认为文章的软件发展历史正是答案，软件工程归根结底是为各行各业的需求服务的，而随着需求的复杂度越来越高，用户的要求越来越高，软件也越复杂，形态也在不断变化，所以没有一种方法论能称得上是银弹，只能说某一种方法论适合某一种需求。这也正是架构师存在的意义，去选择合适的技术，如果有银弹，还要架构师干嘛！以上只是个人见解！

* 软件本身的复杂度难以度量，随时间和规模发展，原有的解决方案很快难适应，人们就不断总结经验模式和设计解决新困难的办法，但是不管什么样的架构设计都是在尽量满足适应我们可能遇到的问题的解决方案，不是解决问题方案。生活中我们的应用从单体到主备再到集群、分布式、微服务最后到最新的Service Mesh，这些其实都是解决和改善、完善、优化我们在软件开发遇到的问题。There is no silver bullet.

### 3.架构设计的目的

* 架构设计的真正目的

  架构设计的主要目的的是为了**解决软件系统复杂度带来的问题**。

* 架构设计应该注意的点：

  * 1）从实际项目需求着手，分析系统复杂性并针对复杂点进行设计。
  * 2）架构设计应有针对性，避免盲目求大求全。

* 简单系统的架构设计应从那些方面分析：

  * 1）性能：web服务器，数据库，缓存。
  * 2）可扩展性：应根据系统的实际需求进行考虑。
  * 3）高可用：负载均衡（异地多活），存储高可用（机器故障-设计MySQL同机房主备方案、机房故障-设计MySQL跨机房同步方案）。
  * 4）安全性：信息隐私、金融相关。
  * 5）成本：服务器成本、人力成本、维护成本。

* 案例：大学的学生管理系统

  * 性能：采用Nginx，MySQL数据库，无需缓存。
  
  * 可扩展性：系统功能稳定，可扩展空间小。
  
  * 高可用：无需负载均衡，需考虑数据库存储高可用。
  
  * 安全性：学生信息有一定隐私性，只需做三点：Nginx 提供 ACL 控制、用户账号密码管理、数据库访问权限控制。
  
  * 成本：系统业务简单，成本较低。
  
    ![1](E:\markdown笔记\笔记图片\14\1.jpg)

### 4.复杂度来源：高性能

* 软件系统的高性能所带来的复杂度体现在两个方面：

  * 单台计算机内部为了高性能带来的复杂度
  * 多台计算机集群为了高性能带来的复杂度

* 单机复杂度

  * 计算机的发展历史

    * 早期计算机：

      1. 特征：只有输入、计算和输出功能
      2. 工作方式：输入指令->计算机处理，输入速度是远远比不上计算机的运算速度的，性能低下

    * 批处理计算机

      1. 特征：预先编辑指令，制作指令清单
      2. 工作方式：指令清单->计算机处理，计算机执行的过程中无须等待人工手工操作，性能有所提升
      3. 缺点：计算机一次只能执行一个任务，在 I/O 操作的过程中，CPU 其实是空闲的，而这个空闲时间本来是可以进行其他计算的。

    * 进程的发明

      1. 特征：用进程来对应一个任务，每个任务都有自己独立的内存空间，进程间互不相关，由操作系统来进行调度。计算机性能再次提升。
      2. 工作方式：为了达到多进程并行运行的目的，采取了分时的方式，即把 CPU的时间分成很多片段，每个片段只能执行某个进程中的指令。
      3. 优点：从操作系统和CPU角度：多进程是串行执行的；而从用户角度：多进程是并行处理的。

    * 进程间的通信

      1. 出现的原因：为了避免进程的频繁读写，使任务设计变得更灵活，需要进程间进行通信。
      2. 特征：进程间通信的各种方式被设计出来了，包括管道、消息队列、信号量、共享存储等。

    * 线程的出现

      1. 出现的原因：多进程多任务可以并行处理任务（分时执行，感觉像并行），但是单个进程只能串行执行，多进程内部的子任务也需要并行执行。
      2. 定义：线程是进程内部的子任务，但这些子任务都共享同一份进程数据。为了保证数据的正确性，又发明了互斥锁机制。
      3. 特征：操作系统调度的最小单位就变成了线程，而进程变成了操作系统分配资源的最小单位。

      **做到时间上真正的并行，多个 CPU 能够同时执行计算任务，从而实现真正意义上的多任务并行的方案**：

      * SMP（Symmetric Multi-Processor，对称多处理器结构）

      * NUMA（Non-Uniform Memory Access，非一致存储访问结构）

      * MPP（Massive Parallel Processing，海量并行处理结构）

        其中 SMP 是我们最常见的，目前流行的多核处理器就是 SMP方案。
  
* 集群的复杂度

  通过大量机器来提升性能，并不仅仅是增加机器这么简单，让多台机器配合起来达到高性能的目的，是一个复杂的任务。

  * 任务分配

    1. 定义：任务分配的意思是指每台机器都可以处理完整的业务任务，不同的任务分配到不同的机器上执行。1台服务器扩展到多台服务器，任务需要分配到不同的服务器上去执行。突破单台机器处理性能的瓶颈，通过**增加更多的机器**来满足业务的性能需求。
    2. 核心：任务分配器，任务分配器和业务服务器之间连接和交互方式、连接的管理，任务分配器的算法
    3. 升级：多台任务分配器
    4. 任务的分配：任务可以是业务任务，也可以是计算任务（缓存、存储、运算等）

  * 任务分解

    1. 定义：分解业务

       ![2](E:\markdown笔记\笔记图片\14\2.png)

    2. 简单的系统更加容易做到高性能

       功能简单，影响性能的因素少，可以针对性优化

    3. 可以针对单个任务进行扩展

       可以针对性优化，风险小

    4. 注意点：

       * 业务系统不是分的越小越好（各系统间的通信要耗费时间）
       * 把握好任务分解的粒度

* 优秀评论：

  *   面试官: 小伙子，说下进程和线程？
    我: 
    1， 早期的计算机是没有操作系统的，只有输入，计算，输出。手工输入速度远低于计算机的计算速度。

    2， 于是出现了批处理操作系统，通过纸带，磁带等工具预先写入指令，形成一个指令清单（即任务）交给计算机处理。但批处理系统的缺点是只能有一个任务，而且当计算机在进行I/O处理时，CPU是空闲的。

    3， 世人发明了进程，一个进程就代表一个任务，多个进程通过分时操作能让用户认为并行操作多任务，进程间的资源是独立单元，但是可以通过介质进行通信。缺点：进程内只进行串行处理，无法很好地分工合作提高处理效率。

    4， 于是就有了操作系统调度的最小单元-线程，线程能够使进程内的子任务能够共享进程内的资源，并并行工作，大大提高操作系统的性能。

    区别：
    线程是任务调度的最小单元，共用进程内的资源。
    进程是资源分配的最小单元，与其他进程资源互相独立。  

  

  


​        