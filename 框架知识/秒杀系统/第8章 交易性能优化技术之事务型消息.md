# 8-1 事务型消息

## 问题一：扣减库存成功，但是提交订单入库失败

### 解决方案

这个问题是说按照之前的设计，我们将redis中的缓存库存进行扣减，然后发一条消息到rockmq，在消费者的逻辑中将数据库中的库存进行扣减。这样做乍一看挺完美的，但是有一个问题，我们这边通过消息队列异步将数据库中的库存进行了扣减，那么如果后续订单的入库出现的失败怎么办？这样就会产生很多库存被扣减，但是没有对应的订单数据的情况。针对这种情况我们做出的改动：

1. 在缓存中进行库存扣减时，先不通过消息队列发送消息去扣减数据库的库存。
2. 在订单入库之后再发消息进行数据库库存的扣减。

### 遗留的问题

这里我们在方法上使用的是Spring的`@Transcational`注解进行事务控制。如果我们按照上面的方案执行之后，因为Spring的注解事务是在方法结束之后才会去执行commit，如果此时因网络问题commit失败，但是我的消息已经发了，还是会出现存存扣减了，找不对对应的订单，会出现库存堆积的情况。

这个时候Spring提供了一个API：

```Java
TransactionSynchronizationManager.registerSynchronization(new TransactionSynchronizationAdapter() {
    @Override
    public void afterCommit(){
        //异步更新库存
        boolean mqResult = itemService.asyncDecreaseStock(itemId,amount);
        if(!mqResult){
            itemService.increaseStock(itemId,amount);
            throw new BusinessException(EmBusinessError.MQ_SEND_FAIL);
        }
    }

})
```

这个API会在事务提交执行执行，但是这里又会有一个问题出现，就是如果订单提交成功了，但是我发送消息到消息队列失败了怎么办？

## 问题二：如果在订单入库之后再发送消息到消息队列，发送失败了怎么办

