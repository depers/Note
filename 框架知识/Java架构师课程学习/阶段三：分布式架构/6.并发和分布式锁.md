# 6.并发和分布式锁

## 第一章 认识锁

### 1. 什么是锁

* 定义：锁（Lock）或互斥（mutex）是一种同步机制，用于在有许多执行线程的环境中强制对资源的访问控制。锁旨在强制实施互斥排他、并发控制策略。

* 场景：假设我们去超市买东西，需要寄存自己的东西到储物柜。假如有3个人，但是储物柜只有1个，大家同时要往这个柜子里面放东西，这个场景就构造了一个多线程竞争的案例。

  1. 我们先创建一个柜子的类，假设柜子中存储的物品就是数字。

     ```java
     /**
      * @author : depers
      * @program : mybatis
      * @description: 柜子，柜子中存储的是数字
      * @date : Created in 2021/4/26 20:38
      */
     public class Cabinet {
     
         // 存储在柜子里面的数字
         private int storeNumber;
     
         public void setStoreNumber(int storeNumber) {
             this.storeNumber = storeNumber;
         }
     
         public int getStoreNumber() {
             return this.storeNumber;
         }
     }
     ```

  2. 抽象用户，这里同时有3个人

     ```java
     /**
      * @author : depers
      * @program : mybatis
      * @description: 用户
      * @date : Created in 2021/4/26 20:40
      */
     public class User {
     
         // 柜子
         private Cabinet cabinet;
     
         // 存储的数字
         private int storeNumber;
     
         public User(Cabinet cabinet, int storeNumber) {
             this.cabinet = cabinet;
             this.storeNumber = storeNumber;
         }
     
         public void useCabinet() {
             cabinet.setStoreNumber(storeNumber);
         }
     }
     ```

  3. 创建一个启动类，来模拟三个人竞争储物柜的场景

     ```java
     /**
      * @author : depers
      * @program : mybatis
      * @description: 启动类，模拟抢盘子
      * @date : Created in 2021/4/26 20:42
      */
     public class Starter {
     
         public static void main(String[] args) {
             // 创建一个柜子实例，因为只有一个柜子
             Cabinet cabinet = new Cabinet();
     
             // 新建一个线程池，有三个线程模拟三个用户
             ExecutorService es = Executors.newFixedThreadPool(3);
     
             // 测试不加同步控制
             testSimple(es, cabinet);
     
             // 添加同步控制
             // testSync(es, cabinet);
     
             es.shutdown();
         }
     
     
         static void testSimple(ExecutorService es, Cabinet cabinet) {
             for (int i = 0; i < 3; i++) {
                 final int storeNumber = i;
                 es.execute(()->{
                     User user = new User(cabinet, storeNumber);
                     user.useCabinet();
                     System.out.println("我是用户" + storeNumber + ", 我存储的数字是：" + cabinet.getStoreNumber());
                 });
             }
         }
     
         static void testSync(ExecutorService es, Cabinet cabinet) {
             for (int i = 0; i < 3; i++) {
                 final int storeNumber = i;
                 es.execute(()->{
                     synchronized (cabinet) {
                         User user = new User(cabinet, storeNumber);
                         user.useCabinet();
                         System.out.println("我是用户" + storeNumber + ", 我存储的数字是：" + cabinet.getStoreNumber());
                     }
                 });
             }
         }
     
     }
     ```

     执行`testSample`方法，效果如下。这种情况下因为三个线程同步执行，三个用户同时去储物柜放东西，但是储物柜里面只能放一件东西，导致打印出了数字其实是最后一个线程所设置的值，因为三个线程同时持有一个柜子，所以打印出的结果是一样的。

     ```
     我是用户2, 我存储的数字是：0
     我是用户1, 我存储的数字是：0
     我是用户0, 我存储的数字是：0
     ```

     就需要锁去控制，怎么解决这个问题呢？Java中有一个关键字`synchronized`，他可以放在代码块或是方法上，这个关键字表示只有获得锁的线程才能执行这个代码块或是方法。因为在这个场景中Cabinet是一个临界资源（竞争资源），所以我们使用`synchronized`代码块来做这件事。

     执行`testSync`方法，效果如下：

     ```java
     我是用户0, 我存储的数字是：0
     我是用户1, 我存储的数字是：1
     我是用户2, 我存储的数字是：2
     ```

     当线程一获得锁时，其他线程就只能等待，所以上面的打印结果是合适的。

### 2. Java中单体应用锁的局限性&分布式锁

#### 1. 互联网架构的演进

![](../../../笔记图片/20/3-6/1.jpg)

![](../../../笔记图片/20/3-6/2.jpg)



#### 2. 单体应用锁的局限性

![](../../../笔记图片/20/3-6/3.jpg)

#### 3. 什么是分布式锁

![](../../../笔记图片/20/3-6/4.jpg)

#### 4. 分布式锁的设计思路

![](../../../笔记图片/20/3-6/5.jpg)

#### 5. 目前存在的分布式的方案

![](../../../笔记图片/20/3-6/6.jpg)

### 3. Java中锁的解决方案

### 1. 乐观锁和悲观锁

