# 4. 分布式消息队列-RabbitMQ

## 第一章 分布式小队列（MQ）认知提升

### 1-1. 学习指南

#### 1. 主要内容

* 分布式小队列（MQ）认知提升
* RabbitMQ实战
* RabbitMQ可靠性投递基础组件封装
* Kafka应用实战
* Kafka高吞吐量日志收集实战
* 架构思考：分布式日志、跟踪、告警、分析平台

#### 2. 分布式小队列（MQ）认知提升内容

* 业界主流的分布式消息队列（MQ）与技术选型
* ActiveMQ特性原理与集群架构【预习或是复习】
* RabbitMQ特性原理与集群架构解析
* RocketMQ特性原理与集群架构【预习或是复习】
* Kafka特性原理与集群架构解析

### 1-2 业界主流的分布式消息队列（MQ）与技术选型

* 分布式消息队列（MQ）应用场景

  参考博文：https://www.cnblogs.com/yanglang/p/9259172.html

  * 服务解耦

    场景说明：用户下单后，订单系统需要通知库存系统。传统的做法是，订单系统调用库存系统的接口，假如库存系统无法访问，则订单减库存将失败，从而导致订单失败。

    加入消息队列后：

    * 订单系统：用户下单后，订单系统完成持久化处理，将消息写入消息队列，返回用户订单下单成功
    * 库存系统：订阅下单的消息，采用拉/推的方式，获取下单信息，库存系统根据下单信息，进行库存操作

    例如：在下单时库存系统不能正常使用。也不影响正常下单，因为下单后，订单系统写入消息队列就不再关心其他的后续操作了。实现订单系统与库存系统的应用解耦

  * 削峰填谷

    一般在秒杀或团抢活动中使用广泛；

    应用场景：秒杀活动，一般会因为流量过大，导致流量暴增，应用挂掉。为解决这个问题，一般需要在应用前端加入消息队列。

    * 可以控制活动的人数
    * 可以缓解短时间内高流量压垮应用
    * 用户的请求，服务器接收后，首先写入消息队列。假如消息队列长度超过最大数量，则直接抛弃用户请求或跳转到错误页面
    * 秒杀业务根据消息队列中的请求信息，再做后续处理

  * 异步化缓冲

    场景说明：用户注册后，需要发注册邮件和注册短信。传统的做法有两种 1.串行的方式；2.并行方式

    * 串行方式：将注册信息写入[数据库](http://lib.csdn.net/base/mysql)成功后，发送注册邮件，再发送注册短信。以上三个任务全部完成后，返回给客户端
    * 并行方式：将注册信息写入数据库成功后，发送注册邮件的同时，发送注册短信。以上三个任务完成后，返回给客户端。与串行的差别是，并行的方式可以提高处理的时间

    加入消息队列后：

    用户的响应时间相当于是注册信息写入数据库的时间。注册邮件，发送短信写入消息队列后，直接返回，因此写入消息队列的速度很快，基本可以忽略。

  * 日志处理

    日志处理是指将消息队列用在日志处理中，比如Kafka的应用，解决大量日志传输的问题。

    * 日志采集客户端，负责日志数据采集，定时写受写入Kafka队列
    * Kafka消息队列，负责日志数据的接收，存储和转发
    * 日志处理应用：订阅并消费kafka队列中的日志数据

* 分布式消息队列（MQ）应用思考点

  1. 生产端可靠性投递
  2. 消费端幂等
  3. MQ的高可用
  4. MQ的低延时
  5. MQ的可靠性
  6. MQ的消息的堆积能力
  7. MQ的扩展性
  8. 等等...

### 1-3 mq的技术选型关注点

* 业界主流的分布式消息队列

  1. ActiveMQ
  2. RabbitMQ
  3. RocketMQ
  4. Kafka

* 如何进行技术选型

  1. 各个MQ的性能、优缺点、相应的业务场景

    * ActiveMQ

      用于传统行业，中小型公司；

      并发和消息的承载能力一般；
    
    * RabbitMQ

      横向拓展能力弱；
    
  2. 集群结构模式 、分布式、可扩展、高可用、可维护性
  
  3. 综合成本问题，集群规模，人员成本
  
  4. 未来的方向、规划、思考
  
### 1-4 ActiveMQ集群架构与原理解析

  ![](../../../笔记图片/20/3-4/1.png)

### 1-5 RabbitMQ集群架构模型与原理解析

* RabbitMQ四种集群架构

  * 主备模式
  * 远程模式
  * 镜像模式（推荐）
  * 多活模式

* 主备模式

  * warren（兔子窝），一个主/备方案（主节点如果挂了，从节点提供服务，和ActiveMQ利用Zookeeper做主/备一样）

    也就是一个主/备方案，主节点提供读写，备用节点不提供读写。如果主节点挂了，就切换到备用节点，原来的备用节点升级为主节点提供读写服务，当原来的主节点恢复运行后，原来的主节点就变成备用节点，和 activeMQ 利用 zookeeper 做主/备一样，也可以一主多备。

  * 架构图

    ![](../../../笔记图片/20/3-4/2.jpg)

  * 主备模式-HaProxy配置

    ![](../../../笔记图片/20/3-4/3.jpg)

* 远程模式

  * 远距离通信和复制，可以实现双活的一种模式，简称Shovel模式。所谓的 shovel 就是把消息进行不同数据中心的复制工作，可以跨地域的让两个 MQ 集群互联，远距离通信和复制。

  * 所谓Shovel就是我们可以把消息进行不同数据中心的复制工作，可以跨地域的让两个MQ集群互联

  * 缺点：配置复杂，不推荐

  * Shovel架构模型

    ![](../../../笔记图片/20/3-4/4.jpg)

    RabbitMQ Goleta warehouse和RabbitMQ Carpinteria warehouse是两个不同地域的Rabbit集群。

    上面的图也就是说，跨地域的两个RabbitMQ集群会在空闲时进行数据复制。

  * Shovel集群的拓扑图

    当第一个集群消息处理不过来或是出现故障时，可以将消息转到第二个集群去做处理。

    ![](../../../笔记图片/20/3-4/5.jpg)

  * Shovel集群配置步骤

    ![](../../../笔记图片/20/3-4/6.jpg)

    ![](../../../笔记图片/20/3-4/7.jpg)

    ![](../../../笔记图片/20/3-4/8.jpg)

* 镜像模式

  * 集群模式非常经典的就是Mirror镜像模式，保证100%数据不丢失

  * 在实际工作中用的最多，并且实现集群非常的简单，一般互联网大厂都会构建这种镜像集群模式

  * Mirror镜像模式的特点

    * 高可靠
    * 数据同步
    * 3节点（防止脑裂）
    * 无法横向扩容（缺点）

  * RabbitMQ集群架构图

    用 KeepAlived 做了 HA-Proxy 的高可用，然后有 3 个节点的 MQ 服务，消息发送到主节点上，主节点通过 mirror 队列把数据同步到其他的 MQ 节点，这样来实现其高可靠。

    ![](../../../笔记图片/20/3-4/9.jpg)

* 多活模式

  * 这种模式也是实现异地数据复制的主流模式，因为Shovel模式配置比较复杂，所以一般来说实现异地集群都是使用这种双活或是多活模型来实现的

  * 这种模式需要依赖RabbitMQ的federation插件，可以实现持续的可靠的AMQP数据通信，多活模式实际配置与应用非常简单

  * Rabbit部署架构采用双中心模式（多中心），那么在两套（或多套）数据中心各部署一套RabbitMQ集群，各中心的RabbitMQ服务除了需要为业务提供正常的消息服务外，中心之间还需要实现部分队列消息共享

  * 多活集群架构图

    ![](../../../笔记图片/20/3-4/10.jpg)

  * 多活模式-Federation插件

    federation 插件是一个不需要构建 cluster ，而在 brokers 之间传输消息的高性能插件，federation 插件可以在 brokers 或者 cluster 之间传输消息，连接的双方可以使用不同的 users 和 virtual hosts，双方也可以使用不同版本的 rabbitMQ 和 erlang。federation 插件使用 AMQP 协议通信，可以接受不连续的传输。

    federation 不是建立在集群上的，而是建立在单个节点上的，如图上黄色的 rabbit node 3 可以与绿色的 node1、node2、node3 中的任意一个利用 federation 插件进行数据同步。

    ![](../../../笔记图片/20/3-4/11.jpg)

    如上图所示，federation exchanges 可以看成 downstream 从 upstream 主动拉取消息，但是并不是拉取所有消息，必须是在 downstream 上已经明确定义 Bingdings 关系的 exchange，也就是有实际的物理 queue 来接收消息，才会从 upstream 拉取消息到 downstream 。

    它使用 AMQP 协议实现代理间通信，downstream 会将绑定关系组合在一起，绑定/解绑命令将发送到 upstream 交换机。因此，federation exchange 只接收具有订阅的消息。

### 1-6 RocketMQ集群架构与原理解析

![](../../../笔记图片/20/3-4/12.png)

### 1-7 Kafka特性原理与集群架构解析

#### 1. Kafka介绍

* Kafka是Linkedin开源的分布式消息系统，目前归属于Apache顶级项目
* Kafka主要特点是基于Pull的模式来处理消息消费，追求高吞吐量，一开始的目的就是用于日志收集和传输
* 0.8版本开始支持复制，不支持事务，对消息的重复、丢失、错误没有严格要求，适合产生大量数据的互联网服务的数据收集业务
* Kafka的特点
  * 分布式
  * 跨平台
  * 实时性强
  * 伸缩性强，支持水平扩展
* Kafka高性能的原因
  * 顺序写，Page Cache空中接力，高效读写
  * 高性能，高吞吐
  * 后台异步、主动Flush
  * IO于预读策略，IO调度

### 1-8 kafka高性能核心pagecache与zerocopy原理解析

**Page cache**：页面缓存，是操作系统实现的一种磁盘缓存机制， 以此来减少磁盘IO操作。就是把磁盘中的数据缓存到内存中，将对磁盘访问变成对内存的访问。

如下图所示，一次网络正常文件读取的流程需要四次文件复制。

![](../../../笔记图片/20/3-4/13.jpg)

**zerocopy**，一次拷贝，Kafka就采用了这种方式。将磁盘中的数据读取到page cache中一次，然后将数据直接发送到网卡，发送给不同订阅者相同数据是可以复用同一个页面缓存，避免了重复复制的情况。如下如所示：
![](../../../笔记图片/20/3-4/14.jpg)

### 1-9 Kafka集群模式

![](../../../笔记图片/20/3-4/15.jpg)

### 1-10 本章总结

![](../../../笔记图片/20/3-4/16.jpg)

## 第二章 RabbitMQ实战

### 2-1学习指南

* AMQP核心概念
* 急速安装与入门
* RabbitMQ核心API
* RabbitMQ高级特性
* RabbitMQ集群架构实操
* 与SpringBoot整合实战-生产端和消费端详解
* MQ基础组件封装与实战

### 2-3 RabbitMQ简单入门
RabbitMQ是一个开源的消息代理和队列服务器，用来通过普通协议在完全不同的应用之间共享数据，RabbitMQ是使用Erlang语言来编写的，并且RabbitMQ是基
议的。各个互联网大厂都在使用RabbitMQ作为消息中间件，为什么呢，下面我们来一起看看，“她” 都有哪些优点！

* 采用Erlang语言作为底层实现：Erlang有着和原生Socket一样的延迟
* 开源、性能优秀，稳定性保障
* 提供可靠性消息投递模式（confirm）、返回模式（ return ）
* 与SpringAMQP完美的整合、API丰富
* 集群模式丰富，表达式配置，HA模式，镜像队列模型
* 保证数据不丢失的前提做到高可靠性、可用性

### 2-4 RabbitMQ高性能的原因

* Erlang语言最初在于交换机领域使用，是专门为通信应用设计的，比如控制交换机或者变换协议等，因此非常适 合于构建分布式，实时软[并行计算系统](https://baike.baidu.com/item/并行计算系统/19130839)。
* Erlang的优点：Erlang有着和原生Socket一样的延迟。

### 2-5 AMQP高级消息队列协议

* AMQP全称：Advanced Message Queuing Protocol，高级消息队里协议

* AMQP定义：是具有线代特征的二进制协议，是一个提供统一消息服务的应用层标准高级消息队列协议，是应用层协议的一个开放标准，为面向消息的中间件设计。

* 下图表达了AMQP协议的一些核心部件：消息的生产者publisher、消息的消费者consumer、MQBroker（Server）、以及内部的Virtual Host、Exchange、Message Queue

  ![](../../../笔记图片/20/3-4/17.jpg)

### 2-6 AMQP核心概念讲解.

AMQP专有名词解释：

* Server：又称Broker，接受客户端的连接，实现AMQP实体服务
* Connection：连接，应用程序与Broker的网络连接
* Channel：网络信道，几乎所有的操作都在Channel中进行，Channel是进行消息读写的通道。客户端可建立多个Channel，每个Channel代表一个会话任务。
* Message：消息，服务器和应用程序之间传送的数据，由Properties和Body组成。Properties可以对消息进行修饰，比如消息的优先级、延迟等高级特性；Body则就是消息体内容。
* Virtual host：虚拟地址，用于进行逻辑隔离，最上层的消息路由。一个Virtual Host里面可以有若干个Exchange和Queue，同一个Virtual Host里面可以有若干个Exchange和Queue，同一个Virtual Host里面不能有相同名称的Exchange或Queue。
* Exchange：交换机，接收消息，根据路由键转发消息到绑定的队列。
* Binding：Exchange和Queue之间的虚拟连接， binding中可以包含routing key。
* Routing key： 一个路由规则，虚拟机可用它来确定如何路由一个特定消息。
* Queue：也称为Message Queue，消息队列，保存信息并将它们转发给消费者。





