## 02.分布式搜索引擎-Elasticsearch

## 第1章

### 1-1 本章概述

1. 本章概述
   * 分布式搜索引擎
   * 搜索引擎技术选型
   * 什么是Elasticsearch？应用场景
   * ES可视化插件、IK分词器、词库
   * ES快速入门、核心术语、文档结构
   * 安装ES，基本操作
   * DSL搜索
   * ES的集群原理
   * ES与数据库数据同步
   * ES与Spring Boot整合实现搜索
   * ES的geo坐标搜索
2. 目前搜索的弊端
   * 空格支持
   * 拆词查询
   * 搜素内容不能高亮
   * 海量数据查库

### 1-2 分布式搜索引擎：lucene vs  solr  vs elasticsearch

1. 什么是分布式搜索引擎
   * 搜索引擎
   * 分布式存储和搜索
2. lucene vs  solr  vs elasticsearch
   * 倒排序索引
   * Lucene是类库
   * Solr基于lucene
   * ES基于lucene
3. ES官网：https://www.elastic.co/cn/

### 1-3 elasticsearch 核心术语

* 索引 index，对应于关系型数据库的**表**
* 类型 type，对应于关系型数据库的**表逻辑类型**（在新版本中已被去掉）
* 文档 document，对应于关系型数据库的**行**（以Json的形式存在）
* 字段 fields，对应于关系型数据库的**列**
* 映射 mapping，对应于关系型数据库的**表结构定义**
* 近实时 NRT，Near real time，新索引和文档的建立和用户的搜索存在一定的延时
* 节点 node，每一个服务器
* shard和replica，数据分片与备份

### 1-5 elasticsearch 集群架构原理

![](E:\markdown笔记\笔记图片\8\59.jpg)

shard是为了将数据分片，提高吞吐量的，保障高性能的；

replica是为了保障在shard宕机情况下，实现高可用的；

### 1-6 什么是倒排索引

![](E:\markdown笔记\笔记图片\8\60.jpg)

### 1-7 安装 elasticsearch

1. 下载es进行解压安装

2. 对elasticsearch.yml进行配置

   * 配置集群名称：

     ```
     cluster.name: mall-elasticSearch
     ```

   * 配置节点名称：

     ```
     node.name: es-node-1
     ```

   * 配置数据存储路径

     ```
     path.data: D:\program_file\elasticsearch-7.8.1\data
     ```

   * 配置日志储存路径

     ```
     path.logs: D:\program_file\elasticsearch-7.8.1\logs
     ```

   * 设置绑定的ip地址，`0.0.0.0`代表可以远程连接，不受ip限制

     ```
     network.host: 0.0.0.0
     ```

   * 配置初始节点

     ```
     cluster.initial_master_nodes: ["es-node-1"]
     ```

3. 对jvm.options进行配置：

   修改总堆空间的初始大小和总堆空间的最大大小：

   ```
   -Xms128m
   -Xmx128m
   ```

4. 使用命令`whoami`查看当前用户，如果是root用户是不允许启动es的，必须新建一个用户去启动。具体命令如下：

   ```
   # 创建用户
   useradd esuser
   
   # 授权,
   # -R : 处理指定目录以及其子目录下的所有文件
   # user : 新的文件拥有者的使用者 ID
   # group : 新的文件拥有者的使用者组(group)
   # chown -R user:group /user/...
   chown -R esuser:esuser /user/local/myapp/elasticsearch-7.8.1
   ```

5. 启动es

   * 前台启动

     ```
     ./elasticsearch
     ```

   * 后台启动，启动之后访问http://localhost:9200/就可以看到es的相关信息

     ```
     ./elasticsearch -d
     ```

   * 后台关闭：

     ```
     jps elasticsearch
     
     kill <进程id>
     ```
   
6. 安装过程中的问题

   ![](E:\markdown笔记\笔记图片\8\68.jpg)

### 1-9 安装es-header插件

* es haeder的github地址：https://github.com/mobz/elasticsearch-head
* 可以在github上下载elasticsearch-Head插件：https://github.com/mobz/elasticsearch-head/blob/master/crx/es-head.crx下载到本地。
* 如果直接拖拽到Chrome会不能使用，告诉你非Chrome来源的。这个时候将文件后缀名".crx"改为“.rar”，然后解压到文件夹里，再通过Chrome“加载已解压的扩展程序”按钮加入文件夹就可以使用了。

## 第2章

### 2-1 head与postman基于索引的基本操作

1. 使用es-head进行相关接口的调用

   ![](E:\markdown笔记\笔记图片\8\72.png)

2. 使用postman进行相关接口的调用

   ![](E:\markdown笔记\笔记图片\8\73.png)

3. 索引相关操作

   1. 创建索引

      ![](E:\markdown笔记\笔记图片\8\74.png)

   2. 刚才我们创建的索引有5个分片，点击概览进行查看

      ![](E:\markdown笔记\笔记图片\8\75.png)

   3. 创建有备份的索引

      ![](E:\markdown笔记\笔记图片\8\76.png)

   4. 查看创建的备份索引，其中只要有5个replica是没有被分配的，导致集群的健康值变为了黄色。

      ![](E:\markdown笔记\笔记图片\8\77.png)
      
   5. 通过Rest请求创建索引，相关的接口可以参照https://www.elastic.co/guide/cn/elasticsearch/guide/current/_creating_an_index.html
   
      * 方法：PUT http://localhost:9200/index_basic
   
      * 请求参数
   
        ```
        {
            "settings": {
                "index": {
                    "number_of_shards": "3",
                    "number_of_replicas": "0"
                }
            }
        }
        ```
   
      * 响应参数，说明创建成功：
   
        ```
        {
            "acknowledged": true,
            "shards_acknowledged": true,
            "index": "index_basic"
        }
        ```
   
   6. 查询一个索引：GET http://localhost:9200/my_index
   
   7. 查询所有索引：GET http://localhost:9200/_cat/indices

### 2-3 mappings自定义创建映射

1. es关于映射的定义：https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping.html

2. 观察如下自定义创建隐射：

   * 方法：PUT http://localhost:9200/index_mapping

   * 请求参数

     ```
     {
         "mappings": {
             "properties": {
                 "realname": {
                     "type": "text",
                     "index": true
                 },
                 "username": {
                     "type": "keyword",
                     "index": false
                 }
             }
         }
     }
     ```

   其中：

   * type：https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-types.html

     这两个类型都是字符串类型

     * text：https://www.elastic.co/guide/en/elasticsearch/reference/current/text.html
     * keyword：https://www.elastic.co/guide/en/elasticsearch/reference/current/keyword.html

   * index：https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-index.html

   使用chrome插件查看索引信息：

   ![](E:\markdown笔记\笔记图片\20\3\4.png)

### 2-5 mappings新增数据类型与analyze

* Text analysis：文本分析是将非结构化文本（例如电子邮件的正文或产品说明）转换为针对搜索优化的结构化格式的过程。(https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis.html)

* 一个简单的文本分析案例：

  * 方法：GET http://localhost:9200/index_mapping/_analyze

  * 参数：

    ```
    {
        "field": "realname",
        "text": "The quick brown fox."
    }
    ```

  * 响应：

    ```
    {
        "tokens": [
            {
                "token": "the",
                "start_offset": 0,
                "end_offset": 3,
                "type": "<ALPHANUM>",
                "position": 0
            },
            {
                "token": "quick",
                "start_offset": 4,
                "end_offset": 9,
                "type": "<ALPHANUM>",
                "position": 1
            },
            {
                "token": "brown",
                "start_offset": 10,
                "end_offset": 15,
                "type": "<ALPHANUM>",
                "position": 2
            },
            {
                "token": "fox",
                "start_offset": 16,
                "end_offset": 19,
                "type": "<ALPHANUM>",
                "position": 3
            }
        ]
    }
    ```

* mappings新增数据类型

  * mappings字段不能修改和删除，只能添加

  * 文档地址：https://www.elastic.co/guide/en/elasticsearch/reference/current/indices-put-mapping.html

  * 方法：PUT/POST http://localhost:9200/index_mapping/_mapping

  * 请求参数：

    ```
    {
        "properties": {
            "id": {
                "type": "long"
            },
            "age": {
                "type": "integer"
            },
            "money": {
              	"type": "float"
            },
            "tax": {
                "type": "double" 
            },
            "email": {
            	"type": "keyword"
            },
            "sex": {
              "type": "byte"
            },
            "score": {
                "type": "short"
            },
            "is_teegner": {
              	"type": "boolean"
            },
            "brithday": {
                "type": "date"
            },
            "relationShip": {
              	"type": "object"
            }
        }
    }
    ```

  * 响应参数：

    ```
    {
        "acknowledged": true
    }
    ```

  * 新增数据类型的mappings

    ![](E:\markdown笔记\笔记图片\20\3\5.png)

### 2-6 文档的基本操作 - 添加文档与自动映射

#### 1.添加文档

1. 创建一个分片为1，副本为0的索引

2. 使用postman创建文档：

   * 请求url（`http://localhost:9200/my_doc/_doc/1`）中的最后一个数字是**文档Id**；
   * 请求报文是文档的相关内容；
   * 响应报文`result`为`created`表示创建成功；

   ![](E:\markdown笔记\笔记图片\20\3\6.png)

3. 插入后的结果：

   ![](E:\markdown笔记\笔记图片\20\3\7.png)

#### 2.自动映射

Elasticsearch的最重要功能之一是它试图摆脱束缚，让您尽快开始探索数据。 要为文档建立索引，您不必先创建索引，定义映射类型并定义字段-您只需为文档建立索引，索引，类型和字段就会自动生效。如下图所示：

![8](E:\markdown笔记\笔记图片\20\3\8.png)

### 2-8 文档的基本操作 - 删除与修改

按照上一节的内容我们往索引中添加几个文档。

![](E:\markdown笔记\笔记图片\20\3\9.png)

#### 1.删除文档

1. 删除id为4的文档；

2. 使用postman删除文档：

   * 请求url（`http://localhost:9200/my_doc/_doc/1`）中的最后一个数字是**文档Id**，是**DELETE**请求；
   * 响应result为deleted为删除成功，_version为2表示这是修改的第二个版本，es不会直接删除这个文档，而是在合适的时候才会去删除。

   ![](E:\markdown笔记\笔记图片\20\3\10.png)

#### 2.修改文档

1. 修改id为2的文档的name字段，对文档的局部属性进行修改

2. 使用postman修改文档：

   * 请求url（`http://localhost:9200/my_doc/_doc/2/_update`）中的最后一个数字是**文档Id**，是POST请求；
   * 响应result为updated为修改成功。

   ![](E:\markdown笔记\笔记图片\20\3\11.png)

3. 全量字段修改

   * 请求地址`http://localhost:9200/my_doc/_doc/3`，请求方式为PUT
   * 请求报文中需要写全量字段

   ![](E:\markdown笔记\笔记图片\20\3\12.png)

### 2-10 文档的基本操作 - 查询

#### 1.文档全文的查询

* 请求地址：GET http://localhost:9200/my_doc/_doc/2

* 响应参数：其中_source是文档的全文

  ![](E:\markdown笔记\笔记图片\20\3\13.png)

#### 2.查询所有文档数据

* 请求地址：GET http://localhost:9200/my_doc/_doc/_search

* 响应参数：其中hits数组是所有的文档

  ![](E:\markdown笔记\笔记图片\20\3\14.png)

#### 3.元数据字段

参考文档：https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-fields.html#mapping-fields

* _index：文档数据所属那个索引，理解为数据库的某张表即可。
* \_type：文档数据属于哪个类型，新版本使用_doc 。_
* _id：文档数据的唯一标识，类似数据库中某张表的主键。可以自动生成或者手动指定。
* _score：查询相关度，是否契合用户匹配，分数越高用户的搜索体验越高。
* _version：版本号。
* _source：文档数据，json格式。

![](E:\markdown笔记\笔记图片\20\3\15.png)

#### 4.定制化数据查询

* 请求地址：GET http://localhost:9200/my_doc/_doc/2?_source=id，只要原始json的id字段
* 响应参数：其中_source是查询的结果![](E:\markdown笔记\笔记图片\20\3\16.png)

#### 5.定制化数据查询所有数据

* 请求地址：GET http://localhost:9200/my_doc/_doc/_search?_source=id,name，只要原始json的id字段

* 响应参数：其中_source是查询的结果

  ![](E:\markdown笔记\笔记图片\20\3\17.png)

#### 6.判断某个文档在不在-head请求

  按照之前的描述，如果我们想判断某一个文档在不在，是否需要按照之前第1小节所讲的那样发起一个GET请求。

* 使用Get请求，如下图所示响应体的大小是317个字节

  ![](E:\markdown笔记\笔记图片\20\3\18.png)

* 使用Head请求，如下图所示响应体的大小是87个字节，所以如果要判断一个文档是否存在，推荐使用HEAD请求。

    ![](E:\markdown笔记\笔记图片\20\3\19.png)
    
### 2-12 文档乐观锁控制 if_seq_no与if_primary_term

根据上一节的讲解，每一个文档中都有一些元数据，元数据中包含的`_version：版本号`，他其实就是用来实现乐观锁的。

#### 1.创建、查询、修改文档

1. 创建文档

   ![](E:\markdown笔记\笔记图片\20\3\20.png)

2. 查询文档

   ![](E:\markdown笔记\笔记图片\20\3\21.png)

3. 局部修改文档

   ![](E:\markdown笔记\笔记图片\20\3\22.png)

#### 2.乐观锁控制

参考文档：https://www.elastic.co/guide/en/elasticsearch/reference/7.9/optimistic-concurrency-control.html#optimistic-concurrency-control

为确保文档的较旧版本不会覆盖较新的版本，对文档执行的每项操作均由主分片分配一个序号，以协调更改。 每次操作都会增加**序列号**，因此可以确保较新的操作具有比较旧的操作更高的序列号。 然后，Elasticsearch可以使用操作的序列号来确保分配给它的序列号较小的更改不会覆盖较新的文档版本。

通过查询接口，我们可以看到响应的_seq_no和_primary_term字段中看到分配的序列号和主要术语：

![](E:\markdown笔记\笔记图片\20\3\23.png)

序列号和主要术语唯一地标识更改。 通过记下返回的序列号和主要术语，可以确保仅在检索以来**未对其进行任何其他更改的情况下**，才能更改该文档。 这可以通过设置索引API，更新API或删除API的if_seq_no和if_primary_term参数来完成。

**情况一：乐观锁控制更新失败**

请求地址http://localhost:9200/my_doc/_doc/2001?if_seq_no=7&if_primary_term=4，因为当前的seq_no变为了8，primary term变为了4。版本号高于当前的修改版本，所以版本冲突，更新失败。

![](E:\markdown笔记\笔记图片\20\3\24.png)

**情况二：乐观锁控制更新成功**

请求地址http://localhost:9200/my_doc/_doc/2001?if_seq_no=8&if_primary_term=4，因为当前的seq_no和primary term与更新版本号相同，所以更新成功。

### 2-14 分词与内置分词器

#### 1.分词

参考文档：https://www.elastic.co/guide/en/elasticsearch/reference/7.9/analysis-analyzers.html

如下图所示：

* 请求地址：http://localhost:9200/_analyze
* 请求参数：
  * analyzer 分词器：
    * standard 标准分析器：按照Unicode文本分段算法的定义，将文本划分为单词边界上的各个术语
    * sample 简单分析器：遇到非字母字符时会将文本分为多个词项
    * whitespace 空格分析器：按照空格进行分词
    * stop 结束分析器：去除无意义的单词
    * keyword 关键字分析器：一个“空”分析器，它接受给出的任何文本，并输出与单个术语完全相同的文本
* 响应参数：tokens中的每一个对象包含着响应的分词结果

![](E:\markdown笔记\笔记图片\20\3\26.png)

#### 2.对特定的索引进行分词

如下图请求地址所示，在某一索引下对一段文字进行分词。

关于这部分内容可以参考：https://www.elastic.co/guide/en/elasticsearch/reference/7.9/indices-analyze.html#analyze-api-field-ex

![](E:\markdown笔记\笔记图片\20\3\27.png)

### 2-16 建立ik中文分词器

#### 1.安装ik分词器

ik中文分词器github地址：https://github.com/medcl/elasticsearch-analysis-ik

#### 2.测试ik分词器

中文分词测试，其中将分词器设置为`ik_max_word`。

ik分词器提供了两个分词器选择：`ik_max_word`和`ik_smart`

![](E:\markdown笔记\笔记图片\20\3\28.png)

### 2-18 自定义中文词库

我们利用上一节的中文分词器，分析这么一句话“骚年在慕课网学习”。如下图所示，但是“骚年”这个词并没有被合在一起，“慕课网”这个词也没有被合在一起，遇到这种问题该怎么办。

![](E:\markdown笔记\笔记图片\20\3\29.png)

#### 1. 自定义中文词汇

1. 官方文档https://github.com/medcl/elasticsearch-analysis-ik中的文档如下：

   ```xml
   <!--用户可以在这里配置自己的扩展字典 -->
   <entry key="ext_dict">custom/mydict.dic;custom/single_word_low_freq.dic</entry>
   ```

2. 编辑本地文件**plugins\ik\config\IKAnalyzer.cfg.xml**

   ```xml
   <!--用户可以在这里配置自己的扩展字典 -->
   <entry key="ext_dict">custom.dic</entry>
   ```

3. 编辑**custom.dic**

   ```
   慕课网
   骚年
   ```

4. 接着我们继续做一下本节开始的请求

   ![](E:\markdown笔记\笔记图片\20\3\30.png)

## 第3章 dsl搜索

### 3-1 dsl搜索 - 数据准备

1. 编辑自己扩展的字典，编辑plugins\ik\config\custom.dic

   ```
   慕课网
   骚年
   慕课
   课网
   慕
   课
   网
   ```

2. 创建一个索引**shop**

   ![](E:\markdown笔记\笔记图片\20\3\31.png)

3. 创建映射

   ![](E:\markdown笔记\笔记图片\20\3\32.png)

4. 添加文档，一共录入了12条文档数据

   ![](E:\markdown笔记\笔记图片\20\3\33.png)

### 3-3 dsl搜索 - 入门语法

####1. Query String

##### 1.单条件查询

http://localhost:9200/shop/_search?q=desc:慕课网

##### 2.多条件查询

http://localhost:9200/shop/_search?q=desc:慕课网&q=age:18

##### 3.类型text与Keyword之间的区别

1. 搜索nickname为`super`的查询，我们定义的nickname字段类型为`text`并设置了分词器，所以我们只搜索`super`是可以搜索出结果的。

   ![](E:\markdown笔记\笔记图片\20\3\34.png)
   
2. 搜索username为`super`的查询，我们定义的username的字段类型为`keyword`

   如下图所示，可以看到我们并不能搜索到结果，因为username的字段类型是keyword。

  ![](E:\markdown笔记\笔记图片\20\3\35.png)

  如果我们搜索username为`super hero`，如下图所示就可以搜索到结果。

  ![](E:\markdown笔记\笔记图片\20\3\36.png)

#### 2. 简单的DSL查询

参考文档：https://www.elastic.co/guide/en/elasticsearch/reference/7.9/query-dsl.html

Elasticsearch提供了一个完整的基于JSON的查询DSL(领域特定语言)来定义查询。可以将查询DSL看作查询的AST(抽象语法树)。

DSL (Domain Specific Language) ，特定领域语言，基于JSON格式的数据查询查询更灵活，有利于复杂查询。

##### 1. match查询

返回与所提供的文本、数字、日期或布尔值匹配的文档。在匹配之前对所提供的文本进行分析。

匹配查询是执行全文搜索的标准查询，包括用于模糊匹配的选项。

参考文档：https://www.elastic.co/guide/en/elasticsearch/reference/7.9/query-dsl-match-query.html

如下所示，我们演示了一个简单的dsl查询：

![](E:\markdown笔记\笔记图片\20\3\37.png)

##### 2. exists查询

返回包含字段索引值的文档。

参考文档：https://www.elastic.co/guide/en/elasticsearch/reference/7.9/query-dsl-exists-query.html

如下所示，我们演示了一个简单的dsl查询：

![](E:\markdown笔记\笔记图片\20\3\38.png)

### 3-5 dsl搜索 - 查询所有与分页

#### 1. 查询所有

1. 采用Query String 的方式

   请求http://localhost:9200/shop/_doc/_search

2. 采用DSL的方式

   下面演示的查询类似于SQL语句：`select * from shop`

   参考文档：https://www.elastic.co/guide/en/elasticsearch/reference/7.9/query-dsl-match-all-query.html

   ![](E:\markdown笔记\笔记图片\20\3\39.png)

3. 采用DSL的方式查询特定字段

   下面演示的查询类似于SQL语句：`select id, age, username from shop`

   ![](E:\markdown笔记\笔记图片\20\3\40.png)

#### 2.es-header基本查询的使用

![](E:\markdown笔记\笔记图片\20\3\41.png)

#### 3.分页查询

参数`from`起始查询下标，默认为0；`size`为每页查询的数量。具体操作参见下图：
![42](E:\markdown笔记\笔记图片\20\3\42.png)

### 3-7 dsl搜索 - term与match

#### 1. term

term是代表完全匹配，也就是精确查询，**搜索前不会再对搜索词进行分词拆解**。

term属于精确匹配，只能查单个词。

参考文档：https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-term-query.html

![](E:\markdown笔记\笔记图片\20\3\43.png)

#### 2. match

match进行搜索的时候，会**先进行分词拆分**（分词），拆完后，再来匹配。

![](E:\markdown笔记\笔记图片\20\3\45.png)

#### 3. terms

terms里的`[ ]` 多个是或者的关系，只要满足其中一个词就可以，**搜索前不会再对搜索词进行分词拆解**。

参考文档：https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-terms-query.html

![](E:\markdown笔记\笔记图片\20\3\44.png)

### 3-9 dsl搜索 - match_phrase

* 参考文档：https://www.elastic.co/guide/en/elasticsearch/reference/7.9/query-dsl-match-query-phrase.html

* 特点：

  * match：分词后只要有匹配就返回；
  * match_phrase：分词结果必须在text字段分词中**都包含**，而且**顺序必须相同**，而且必须都是**连续**的。（搜索比较严格）

* 测试结果

  ![](E:\markdown笔记\笔记图片\20\3\46.png)

* **slop**：slop参数告诉match_phrase查询词条能够相隔多远时仍然将文档视为匹配。相隔多远的意思是，你需要移动一个词条多少次来让查询和文档匹配。

  如下图所示，我们查询的“大学 研究生”但是他们之间并不连贯，他们之间还隔了“毕业”，“后”，“考”三个词条，故设置slop为3进行匹配查询。这里**大于等于3**都是可以匹配到的。

  ![](E:\markdown笔记\笔记图片\20\3\47.png)

### 3-11 dsl搜索 - match(operator)与ids

#### 1.operator

用于解释查询值中的文本的布尔逻辑。

参考文档：https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-query.html

* or**(Default)**：例如，查询值capital of Hungary被解释为capital**或**of**或**Hungary。

  ![](E:\markdown笔记\笔记图片\20\3\48.png)

* and：例如，查询值capital of Hungary被解释为capital AND of AND Hungary。

  ![](E:\markdown笔记\笔记图片\20\3\49.png)

#### 2. minimum_should_match

返回文档时必须匹配的子句的最小数目。

参考文档：https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-minimum-should-match.html#query-dsl-minimum-should-match

![](E:\markdown笔记\笔记图片\20\3\50.png)

#### 3.ids

根据文档的id返回文档。该查询使用存储在id字段中的文档id。

参考文档：https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-ids-query.html

![](E:\markdown笔记\笔记图片\20\3\51.png)

### 3-13 dsl搜索 - multi_match与boost

#### 1. multi_match

多匹配查询构建在匹配查询之上，以允许多字段查询。

参考文档：https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-multi-match-query.html

![](E:\markdown笔记\笔记图片\20\3\52.png)

#### 2. 增加搜索字段权重

单个字段可以使用插入符号(^)增强。

![](E:\markdown笔记\笔记图片\20\3\53.png)

### 3-15 dsl搜索 - 布尔查询

布尔查询的文档可以参考：https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-bool-query.html

#### 1. must

子句(query)必须出现在匹配的文档中，并将对分数产生影响。相当于**and**

![](E:\markdown笔记\笔记图片\20\3\54.png)

#### 2. should

子句(query)应该出现在匹配的文档中。相当于**or**

![](E:\markdown笔记\笔记图片\20\3\55.png)

#### 3. must_not

子句(查询)不能出现在匹配的文档中。**查询条件都不满足**。

![](E:\markdown笔记\笔记图片\20\3\56.png)

#### 4. 组合查询

将must，should，must_not进行组合查询。

![](E:\markdown笔记\笔记图片\20\3\57.png)

#### 5. boost

在优先排序子句中，我们解释了如何在搜索时使用boost参数使一个查询子句比另一个查询子句更重要。

参考文档：https://www.elastic.co/guide/en/elasticsearch/guide/2.x/query-time-boosting.html

![](E:\markdown笔记\笔记图片\20\3\58.png)

### 3-17 dsl搜索 - 过滤器

对搜索出来的结果进行数据过滤。不会到es库里去搜，不会去计算文档的相关度分数，所以过滤的性能会比较高，过滤器可以和全文搜索结合在一起使用。
**post_filter**元素是一个顶层元素，只会对搜索结果进行过滤。不会计算数据的匹配度相关性分数，不会根据分数去排序，query则相反，会计算分数，也会按照分使用场景：

* query：根据用户搜索条件检索匹配记录
* post_filter：用于查询后，对结果数据的筛选

实操：查询账户金额大于80元，小于160元的用户。并且生日在1998-07-14的用户。（除此以外还能做其他的match等操作也行）

* gte：大于等于
* lte：小于等于
* gt：大于
* lt：小于

过滤money大于70小于100的数据，查询结果如下：

![](E:\markdown笔记\笔记图片\20\3\59.png)

过滤birthday为1985-06-01的数据，查询结果如下：

![](E:\markdown笔记\笔记图片\20\3\60.png)

### 3-19 dsl搜索 - 排序

#### 1. 简单排序

根据age字段倒序排序。

![](E:\markdown笔记\笔记图片\20\3\61.png)

#### 2. 组合排序

根据age倒序和money正序组合排序。

![](E:\markdown笔记\笔记图片\20\3\62.png)

#### 3. text类型排序

观察下面的两幅图片，我们对nickname进行排序报错了，由于文本会被分词，所以往往要去做排序会报错。而第二幅图username进行排序却没有报错，是因为username是keyword类型的。

![](E:\markdown笔记\笔记图片\20\3\63.png)

![64](E:\markdown笔记\笔记图片\20\3\64.png)

相对text进行分词我们应该怎么做呢？

通常我们可以为这个字段增加额外的一个附属属性，类型为keyword，用于做排序。

* 创建索引

  ![](E:\markdown笔记\笔记图片\20\3\65.png)

* 添加文档

  ![](E:\markdown笔记\笔记图片\20\3\66.png)

* 查询测试

  ![](E:\markdown笔记\笔记图片\20\3\67.png)

### 3-21 dsl搜索 - 高亮highlight

#### 1. 普通高亮

普通高亮的话，高亮短语会被`<em>、</em>`包裹。

![](E:\markdown笔记\笔记图片\20\3\68.png)

#### 2. 定制标签的高亮

如下图参数所示，可以定制高亮短语的标签。

![]()![69](E:\markdown笔记\笔记图片\20\3\69.png)

### 3-23 附：课外拓展 - prefix-fuzzy-wildcard

#### 1. 根据前缀查询

根据前缀去查询

![](E:\markdown笔记\笔记图片\20\3\70.png)

#### 2. 模糊搜索

模糊搜索，并不是指的sql的模糊搜索，而是用户在进行搜索的时候的打字错误现象，搜索引擎会自动纠正，然后尝试匹配索引库中的数据。

![](E:\markdown笔记\笔记图片\20\3\71.png)

参考文档：https://www.elastic.co/guide/cn/elasticsearch/guide/current/fuzzy-match-query.html

#### 3. 占位符查询

占位符查询。

* ？：1个字符
* *：1个或多个字符

![](E:\markdown笔记\笔记图片\20\3\72.png)

参考文档：https://www.elastic.co/guide/en/elasticsearch/reference/7.9/query-dsl-wildcard-query.html

## 第四章

### 4-1 深度分页

* 概述：深度分页也就是用户的分页操作进行的比较深了，例如他要查第1页、2页，这是浅分页，而10000页、20000页就是深度分页了。

* max_window_size限制

  es 目前支持最大的 skip 值是 max_result_window ，默认为 10000 。也就是当 from + size > max_result_window 时，es 将返回错误。

  ![](../../../笔记图片/20/3/73.png)

* 深度分页方式 from+size

  es 默认采用的分页方式是 from+ size 的形式，在深度分页的情况下，这种使用方式效率是非常低的，比如

  from = 9999, size=10， es 需要在各个分片上匹配排序并得到10009条有效数据，然后在结果集10009*3中取最后10条。

  ![](../../../笔记图片/20/3/74.jpg)

* 淘宝的做法

  譬如淘宝搜索限制分页最多80页，如下：

  ![](../../../笔记图片/20/3/74.png)

### 4-3 深度分页 - 提升搜索量

#### 1. 查询搜索量

默认如果没有设置过该值的话，这个请求响应是没有max_result_window。

![](../../../笔记图片/20/3/76.png)

#### 2. 设置搜索量

![](../../../笔记图片/20/3/75.png)

### 4-5 scroll 滚动搜索

参考文档：https://www.elastic.co/guide/cn/elasticsearch/guide/current/scroll.html

注意看请求地址http://localhost:9200/shop/_search?scroll=1m，url后缀的**scroll**=1m

启用游标查询可以通过在查询的时候设置参数 scroll 的值为我们期望的游标查询的过期时间。 游标查询的过期时间会在每次做查询的时候刷新，所以这个时间只需要足够处理当前批的结果就可以了，而不是处理查询结果的所有文档的所需时间。 这个过期时间的参数很重要，因为保持这个游标查询窗口需要消耗资源，所以我们期望如果不再需要维护这种资源就该早点儿释放掉。 设置这个超时能够让 Elasticsearch 在稍后空闲的时候自动释放这部分资源。

* 第一次scroll 滚动搜索（查询初始化）

  游标查询用字段 `_doc` 来排序，每次请求5条数据。

  ![](../../../笔记图片/20/3/77.png)

* 第二次scroll 滚动搜索

  第二次查询的时候url和body里面的内容都变了，需要携带scroll_id

  ![](../../../笔记图片/20/3/78.png)

### 4-7 批量查询 _mget

#### 1. 普通批量查询

* 优点：有额外的数据可以查到took、hits这些。

* 缺点：不能够判断一个文档是否存在，例如下图中10015并不存在，他不做任何处理，只是不显示。

![](../../../笔记图片/20/3/79.png)

#### 2. _mget批量查询

优点：能够判断一个文档是否存在。

缺点：只能查到一个文档的数据，并没有额外的信息。

![](../../../笔记图片/20/3/80.png)