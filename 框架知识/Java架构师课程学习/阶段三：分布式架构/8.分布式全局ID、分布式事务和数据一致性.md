# 8. 分布式全局ID、分布式事务和数据一致性

##  第一章 分布式全局ID

### 1-1 分布式全局id——概述和引发的问题

#### 1. 本章概述

1. 分库分表的系统中，由于id引发的问题
2. 使用UUID作为id实现主键全局唯一性保证
3. 通过统一ID序列表，实现全局id
4. 雪花算法作为全局id
5. 多种方案的比较

#### 2. 分库分表引发的id问题

在通常情况下，每个表都有唯一标识，通常使用id，id通常采用自增的方式，在分库分表的情况下，每张表的id都是从0开始自增的。不同的分片上id可能是重复的，导致id在全局不唯一，进而出现业务上的混乱。

### 1-2 分布式主键UUID

#### 1. UUID

* UUID：通用唯一识别码（Universally Unique Identifier）
* 使用UUID，保证每一条记录的id都是不同的
* 缺点：只是单纯的一个id，没有实际意义，长度32位，太长了
* Mycat不支持UUID的方式，Sharding-Jdbc支持UUID的方式

#### 2. UUID实战

#### 前置准备

1. 将192.168.156.139和192.168.156.140的sharding-orders数据库中的orders_1和orders_2的order_id字段修改为`varchar(32)`
2. 将项目sharding-jdbc-demo的orders表的mapper文件重新生成

##### Spring Boot

1. 编写自定义的分片表达式

   ```java
   /**
    * @author : depers
    * @program : sharding-jdbc-demo
    * @description: 自定义UUID分片策略
    * @date : Created in 2021/8/30 21:28
    */
   public class UuidSharding implements PreciseShardingAlgorithm<String> {
       @Override
       public String doSharding(Collection<String> collection, PreciseShardingValue<String> preciseShardingValue) {
           String uuid = preciseShardingValue.getValue();
           int mode = uuid.hashCode() % collection.size();
   
           String[] strs = collection.toArray(new String[0]);
           mode = Math.abs(mode);
   
           System.out.println("分片表：" + strs[0] + ", " + strs[1]);
           System.out.println("mode = " + mode);
           return strs[mode];
       }
   }
   ```

2. 修改application.properties

   ```properties
   spring.shardingsphere.sharding.tables.orders.table-strategy.standard.sharding-column=order_id
   spring.shardingsphere.sharding.tables.orders.table-strategy.standard.precise-algorithm-class-name=cn.bravedawn.shardingjdbcdemo.sharding.UuidSharding
   
   spring.shardingsphere.sharding.tables.orders.key-generator.column=order_id
   spring.shardingsphere.sharding.tables.orders.key-generator.type=UUID
   ```

3. 运行测试程序

   ```java
   @Test
   public void insertByCustomOrderIdInsert(){
       Orders orders = new Orders();
       orders.setUserId(2);
       orders.setOrderAmount(BigDecimal.TEN);
       orders.setOrderStatus(0);
   
       ordersMapper.insertSelective(orders);
   }
   ```

4. 效果

   ![](../../../笔记图片/20/3-7/11.jpg)

##### Spring命名空间

1. 修改sharding-jdbc.xml

   ```xml
   <sharding:table-rules>
   	<sharding:table-rule logic-table="orders" actual-data-nodes="ms$->{0..1}.orders_$->{1..2}" database-strategy-ref="databaseStrategy" table-strategy-ref="standard" key-generator-ref="uuid"/>
   </sharding:table-rules>
   
   <sharding:key-generator id="uuid" column="order_id" type="UUID"/>
   
   <bean id="uuidSharding" class="cn.bravedawn.shardingjdbcdemo.sharding.UuidSharding"/>
   
   <sharding:standard-strategy id="standard" sharding-column="order_id" precise-algorithm-ref="uuidSharding"/>
   ```

2. 其他和SpringBoot相同

### 1-3 MyCat全局id （统一ID序列表）

* ID的值统一的从一个集中的ID序列生成器中获取。多个数据库从一个ID序列生成器中获取ID。

* ID序列生成器MyCat支持，Sharding-Jdbc不支持。

* MyCat中有两种方式：本地文件方式和数据库方式。

* 本地文件方式用于测试，数据库方式用于生产。
* 优点：ID集中管理，避免重复。
* 缺点：并发量大时，ID生成器压力较大。

#### 本地文件的方式

1. server.xml 中配置：

   ```xml
   <system><property name="sequnceHandlerType">0</property></system>
   ```


   注：sequnceHandlerType 需要配置为 0，表示使用本地文件方式。

2. sequence_conf.properties

   ```
   MY_ORDER.HISIDS=
   MY_ORDER.MINID=1001
   MY_ORDER.MAXID=2000
   MY_ORDER.CURID=1000
   ```

   其中 `HISIDS` 表示使用过的历史分段(一般无特殊需要可不配置)，`MINID` 表示最小 ID 值，`MAXID` 表示最大
   ID 值，`CURID` 表示当前 ID 值。

3. schema.xml

   

4. 启动MyCat：`./mycat console`

5. 

#### 数据库的方式

