# Java 设计模式

这门课所要学的东西：

![](E:\markdown笔记\笔记图片\11\11-1.png)

![](E:\markdown笔记\笔记图片\11\11-2.png)

![](E:\markdown笔记\笔记图片\11\11-3.png)

![](E:\markdown笔记\笔记图片\11\11-4.png)

![](E:\markdown笔记\笔记图片\11\11-5.png)

## 第一章 UML入门

![](E:\markdown笔记\笔记图片\11\11-6.png)

### 1、UML简单入门

* UML定义

  * 统一建模语言(Unified Modeling Language，缩写UML)
  * 非专利的第三代建模和规约语言

* UML特点：

  * UML是一种开放的方法
  * 用于说明、可视化、构建和编写一个正在开发的面向对象的、软件密集系统的制品的开放方法。其中制品指的是在软件开发过程中产生的各种各样的产物，如模型、流程图、源代码和测试用例等。
  * UML展现了一系列最佳工程实践，这些最佳实践在对大规模，复杂系统进行建模方面，特别是在软件架构层次已经被验证有效。

* UML2.2分类

  UML2.2中一共定义了14种图示，分类如下：

  * 结构式图形：强调的是系统式的建模
  * 行为式图形：强调系统模型中触发的事件
  * 交互式图形：属于**行为式**图形子集合，强调系统建模中资料流程

* 结构式图形

  * 静态图（类图，对象图，包图）
  * 实现图（组件图，部署图）
  * 剖面图
  * 复合结构图

* 行为式图形

  * 活动图
  * 状态图
  * 用例图

* 交互式图形

  * 通信图
  * 交互概述图（UML2.0）
  * 时序图（UML2.0）
  * 时间图（UML2.0）

* UML类图

  * Class Diagram：用于表示类、接口、实例等之间相互的静态关系
  * 虽然名字叫类图，但类图中不只有类

* 记忆技巧

  * UML件箭头方向：

    * 从子类指向父类；从实现类指向接口。**提示**：可能会认为子类是以父类为基础的，箭头应从父类指向子类
      * 定义子类时需要通过**extends**关键字指定父类
      * 子类一定是知道父类定义的，但父类并不知道子类的定义
      * 只有知道对方信息时才能指向对方
      * 所以箭头方向是从子类指向父类的
    
  * 实线是继承；虚线是实现。
      * 空心三角箭头：继承或实现
      * **实线-继承**，is a的关系，扩展目的，不虚，很结实
      * **虚线-实现**，虚线代表“虚”，无实体，里面还需要填充很多实现的东西

    * 实线是关联关系，虚线是依赖关系。

      * 实线通常是一个类中有另一个类对象作为属性，其中箭头指向被关联对象。
      * 实现-关联关系：关系稳定，实打实的关系，铁哥们
      * 表示一个类对象和另一个类对象有关联
      * 通常是一个类中有另一个类对象作为属性

      ![](E:\markdown笔记\笔记图片\11\14.jpg)

    * 虚线一般是一个类使用另一个类作为参数使用，或作为返回值，其中箭头指向被依赖的对象。
      * 虚线-依赖关系：临时用一下，若即若离，虚无缥缈，若有若无
      * 表示一种使用关系，一个雷需要借助另一个类来实现功能
      * 一般是一个类使用另一个类作为参数使用，或作为返回值

      ![](E:\markdown笔记\笔记图片\11\15.jpg)

  * 空心菱形表聚合， 实心菱形表组合。

    * 菱形就是个盛东西的器皿（例如盘子）
    * 聚合：代表空器皿里可以放很多相同的东西，聚在一起（箭头方向所指的类），**继承关系**
      * 整体和局部的关系，**两者有着独立的生命周期，是has a的关系**
      * 弱关系
      * 消极的词：弱-空

    ![](E:\markdown笔记\笔记图片\11\11-7.png)

    * 组合：代表满器皿里已经有实体结构的存在，生死与共，会有相同的生命周期
    * 整体和局部的关系，和聚合的关系相比，关系更加强烈。**两者有相同的生命周期，contains-a的关系**
      * 强关系
    * 积极的词：强-满
      * 常见数字表达及含义，假设有A类和B类，数字标记在A类侧
      * 0...1：0或1个实例，表示**某一时刻，B的实例可以和0个或1个实例相关**
        * 0..*：0或多个实例
        * 1..1：1个实例
        * 1    ：只能有一个实例
      * 1..*：至少有一个实例
    

  ![11-8](E:\markdown笔记\笔记图片\11\11-8.png)

    实心菱形表组合：

  - 整体和局部的关系，和聚合的关系相比，关系更加强烈。两周有相同的生命周期，contains-a的关系
    - 两者之间是强关系(实心)
    - 其中菱形在数目少的那一边，比如上面的种情况。一只鸟有两只翅膀，菱形就在鸟的那边
    
    空心菱形表聚合：
    
    * 整体和局部的关系，两者有着独立的生命周期，是has a的关系
    * 两者之间是弱关系(空心)
    * 其中菱形在数目多的那一边，比如上面的种情况。大雁群和大雁，菱形就在大雁群那边
    
    ![](E:\markdown笔记\笔记图片\11\11-9.png)

* UML时序图

  * Sequence Diagam：是显示对象之间交互的图，这些对象是按时间顺序排列的。
  * 时序图中包括的建模元素主要有：对象(Actor)、生命线(Lifeline)、控制焦点(Focus of control)、消息(Meaasge)等

  ![](E:\markdown笔记\笔记图片\11\11-10.png)

### 2、UML类图讲解

![](E:\markdown笔记\笔记图片\11\11-11.png)

上图中有三部分，第一部分是类名，第二部分是类的属性，第三部分是类的方法。

其中就其属性来讲：

* `+`说明是public
* `-`说明是private
* `#`说明是protected
* `~`说明是default，包权限
* `String,char,int,double`这些是类型
* `下划线`说明是个static属性

其中就其方法来说，除了访问限制符：

* `斜体方法`表明是一个抽象方法
* `boolean`表明的是返回值类型

### 3、UML类图讲解-自上而下 

下面主要讲到了几种关系：

* 继承：实线空心箭头；实线：虚线空心箭头
* 依赖关系：虚线箭头；关联关系：实线箭头
* 聚合关系：空心菱形；组合关系：实心菱形

![](E:\markdown笔记\笔记图片\11\11-12.png)

下面我们将对上图进行分析：

* 对于**动物**来说：属性是**生命**，方法是**新陈代谢和繁殖**，**新陈代谢**依赖**氧气、水**。**氧气和水是依赖关系，依赖是虚线，虚线指向被依赖方**
* 对于**鸟**来说：
  * 继承自**动物**，箭头指向**动物**，鸟可以强转为**动物**，但是动物强转为鸟却不一定了（也就是说在Java中子类可以**向上强转**，而父类**不可以先下强转**）。箭头方向为**子类指向父类**（记忆方法可以参考"UML简单入门->记忆技巧->UML件箭头方向"）；
  * 鸟有**羽毛属性**和**下蛋方法**；
  * 鸟和翅膀是**组合关系**，有相同的生命周期，其中1,2表示1只鸟有2个翅膀
  * 鸟作为**动物的子类**，又是**大雁、鸭和企鹅的父类**
* 对于**企鹅**来说：
  * 继承自**鸟**，与**气候**是**关联关系**。关联关系表示两个类的对象之间是由某种关联的，通常是一个类把另一个类作为属性。也就是说我在企鹅里面声明一个气候的**成员变量**。
  * 关联关系使用**实线**，箭头指向**被依赖对象**
* 对于**大雁**来说：
  * 继承自**鸟**，与大雁群是**聚合关系**，大雁群has a 大雁，箭头指向个体；
  * 实现了**飞翔**接口，实线是**虚线空心箭头**，箭头**指向接口**；
* 对于**唐老鸭**来说：
  * 继承自**鸭**
  * 实现了**讲人话**接口（**棒棒糖表示法，接口的另一种表示方法**）

![](E:\markdown笔记\笔记图片\11\16.jpg)

## 第二章 设计原则（七大原则）

* 开闭原则
* 依赖倒置原则
* 单一职责原则
* 接口隔离原则
* 迪米特法则（最少知道原则）
* 里氏替换原则
* 合成/复用原则（组合/复用原则)

设计原则的使用不是必须要遵守的，我是要有度，掌握平衡

### 1. 开闭原则（基础）

* 定义：一个软件实体如类、模块和函数应该对扩展开放，对修改关闭
* 用抽象构建框架，用实现扩展细节
* 优点：提高软件系统的可复用性和可维护性

关于开闭原则的Coding部分请参考：cn.bravedawn.design.principle.openclose

git commit：https://github.com/depers/design_pattern/commit/34108fed9ce6e42e074c9857b66282c6c21234bb

![](E:\markdown笔记\笔记图片\11\11-13.png)

首先我创建了一个接口ICourse，然后我用基类JavaCourse实现了ICourse接口。此时我有一个需求，需要设置一个课程的活动价格，那我们该怎么做呢？

* 法一：在接口里面添加一个getDiscountPrice的方法，然后让JavaCourse去实现这个方法

* 法二：在JavaCourse类里添加下列代码：

  ```java
  public Double getDiscountPrice(){
  	return this.price*0.8;
  }
  ```

* 法三：创建一个JavaDiscountCourse类，继承自JavaCourse然后编写代码：

  ```java
  public class JavaDiscountCourse extends JavaCourse {
  
      public JavaDiscountCourse(Integer id, String name, Double price) {
              super(id, name, price);
      }
  
      public Double getOriginPrice(){
          return super.getPrice();
      }
  
      @Override
      public Double getPrice() {
          return super.getPrice()*0.8;
      }
  }
  ```

  这样我们就可以在**不改变接口和基类的情况下**去做业务的拓展了。

### 2. 依赖倒置原则

* 定义：高层模块不应该依赖低层模块，二者都应该依赖其抽象

* 抽象不应该依赖细节；细节应该依赖抽象
* 针对接口编程，不要针对实现编程
* 优点：可以减少类间的耦合性，提高系统稳定性，提高代码可读性和可维护性，可降低修改程序所造成的风险
* 具体实现参见：cn.bravedawn.design.principle.dependenceinversion，推荐v2和v4
* Git commit：https://github.com/depers/design_pattern/commit/6018afdf1e921bded0c9ed785b54bfa5a072836c

### 3. 单一职责原则

* 定义：不要存在多于一个导致类变更的原因
* 一个类/接口/方法只负责一项职责
* 优点：降低类的复杂度，提高类的可读性，提高系统的可维护性，降低变更引起的风险
* 使用：在实际的项目的开发中，尽量保证接口和方法的单一职责，类的单一职责原则会导致类的很多，这个根据具体情况对待。
* Coding
  * 类的单一职责原则实现
    * cn.bravedawn.design.principle.singleresponsibility.bird
    * 一个类只提供一个功能
  * 接口的单一职责原则实现
    * cn.bravedawn.design.principle.singleresponsibility.course
    * 一个接口只声明和定义一个功能
  * 方法的单一职责原则实现
    * cn.bravedawn.design.principle.singleresponsibility.method
    * 一个方法中只做一件事情
* Git commit：https://github.com/depers/design_pattern/commit/d70351f6915c8bc2afa2f6e78dc259349877ec9f

### 4. 接口隔离原则

* 定义：用多个专门的接口，而不使用单一的总接口，客户端不应该依赖它不需要的接口
* 一个类对一个类的依赖应该建立在最小的接口上
* 建立单一接口，不要建立庞大臃肿的接口
* 尽量细化接口，接口中的方法尽量少
* 注意适度原则，一定要适度
* 优点：符合我们常说的高内聚低耦合的设计思想，从而使得类具有很好的可读性、可扩展性和可维护性
* **单一职责原则与接口隔离原则的区别**
  * 接口隔离原则与单一职责的审视角度是不相同的。
    单一职责要求的是类和接口职责单一，注重的是**职责**，这是**业务逻辑上的划分**，而接口隔离原则要求**接口的方法尽量少**。
  * 例如一个接口的职责可能包含10个方法，这10个方法都放在一个接口中，并且提供给多个模块访问，各个模块按照规定的权限来访问，在系统外通过文档约束“不使用的方法不要访问”，按照单一职责原则是允许的，按照接口隔离原则是不允许的，因为它要求“尽量使用多个专门的接口”。专门的接口就是指提供给每个模块的都应该是单一接口，而不是建立一个庞大的臃肿的接口，容纳所有的客户端访问。
* Coding
  * v1：违背了接口隔离原则，将多个方法的声明混合在一个接口中
  * v2：遵从接口隔离原则，使用专门的接口提供专门的方法
* Git commit：https://github.com/depers/design_pattern/commit/f80cd2420b70d3159d10818268add9ec0cd90a6e

### 5. 迪米特原则

* 定义：一个对象应该对其他对象保持最少的了解，又叫最少知道原则。

* 尽量降低类与类之间的耦合

* 优点：降低类之间的耦合

* 特点：

  * 强调只和朋友交流，不和陌生人说话
  * 朋友：出现在**成员变量**、**方法输入参数**、**方法输出参数**中的类称为成员**朋友类**。而出现在方法体内部的类不属于朋友类。

* Coding

  * v1版本的UML图，根据迪米特法则，Boss不应该接触Course

    ![](E:\markdown笔记\笔记图片\11\17.png)

  * v2版本的UML图，我们解除了Boss与Course之间的关系，转而让TeamLeader去接触

    ![](E:\markdown笔记\笔记图片\11\18.png)

* Git commit：https://github.com/depers/design_pattern/commit/fb1e9f3e64085c065418d0693f8ebf2a6b467bd5