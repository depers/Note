## 第7章 单例模式

### 1. 单例模式讲解

参考博文：https://blog.csdn.net/lovelion/article/details/17517213

* 定义：保证一个类仅有一个实例，并提供一个全局访问点。

* 类型：创建型

* 适用场景：想确保任何情况下都绝对只有一个实例

* 优点：

  1. 在内存中只有一个实例，减少了内存开销
  2. 可以避免对资源的多重占用
  3. 设置全局访问点，严格控制访问

* 缺点：没有接口，扩展困难

* 重点：

  1. 私有构造器

  2. 线程安全

  3. 延迟加载

  4. 序列化和反序列化安全

  5. 反射

  6. Double check

     ![](../../../笔记图片/11/25.jpg)

     ![26](../../../笔记图片/11/26.jpg)

  7. 静态内部类

     ![](../../../笔记图片/11/27.jpg)

* 实用技能

  * 反编译
  * 内存原理
  * 多线程debug

* 相关设计模式

  * 单例模式和工厂模式
  * 单例模式和享元模式


### 2. 单例设计模式-懒汉式及多线程Debug实战

#### 1. 普通的懒汉式单例模式

通常发生在多线程环境中，`if (lazySingleton == null)`就会失效，导致可能会有两个线程同时进入，导致重复创建对象的情况。

```java
/**
 * @author : depers
 * @program : design_pattern
 * @description: 懒汉式,线程不安全
 * @date : Created in 2020/9/29 21:29
 */
public class LazySingleton {

    // 1.在类加载时并不自行实例化，这种技术又称为延迟加载(Lazy Load)技术
    private static LazySingleton lazySingleton = null;

    // 2.禁止外部实例化对象
    private LazySingleton(){

    }

    // 3.提供实例化方法（线程不安全的）
    public static LazySingleton getInstance(){
        if (lazySingleton == null){
            lazySingleton = new LazySingleton(); // 若线程1和线程2都进入到这里，就会存在重复创建对象的情况
        }
        return lazySingleton;
    }
}

```

#### 2.线程安全的懒汉式单例模式

该懒汉式单例类在getInstance()方法前面增加了关键字`synchronized`进行线程锁，以处理多个线程同时访问的问题。但是，上述代码虽然解决了线程安全问题，但是每次调用getInstance()时都需要进行线程锁定判断，**在多线程高并发访问环境中，将会导致系统性能大大降低**。

```java
/**
 * @author : depers
 * @program : design_pattern
 * @description: 懒汉式,线程安全
 * @date : Created in 2020/9/29 21:29
 */
public class LazySingletonSafe {

    // 1.在类加载时并不自行实例化，这种技术又称为延迟加载(Lazy Load)技术
    private static LazySingletonSafe lazySingleton = null;

    // 2.禁止外部实例化对象
    private LazySingletonSafe(){

    }

    // 3.提供实例化方法（线程安全）
    public synchronized static LazySingletonSafe getInstance(){
        if (lazySingleton == null){
            lazySingleton = new LazySingletonSafe();
        }
        return lazySingleton;
    }

    // 3.提供实例化方法，这个效果与上面相同，都是阻塞整个类
    /*
    public static LazySingletonSafe getInstance(){
        synchronized(LazySingletonSafe.class){
            if (lazySingleton == null){
                lazySingleton = new LazySingletonSafe();
            }
        }
        return lazySingleton;
    }
     */
}
```

#### 3. IDEA多线程Debug

在你需要打断的的地方，设置挂起方式为`Thread`，如下图所示：

![](../../../笔记图片/11/24.png)

* 参考博文：https://blog.csdn.net/lovelion/article/details/7420886

* Git commit：https://github.com/depers/design_pattern/commit/f6fa1a2368b8a577c027fb2667723865894eb439