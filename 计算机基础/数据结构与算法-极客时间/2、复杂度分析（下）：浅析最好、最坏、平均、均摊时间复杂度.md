## 复杂度分析（下）：浅析最好、最坏、平均、均摊时间复杂度

### 1.最好情况时间复杂度

在最理想的情况下，执行这段代码的时间复杂。

### 2.最坏时间复杂度

在最糟糕的情况下，执行这段代码的时间复杂度。

### 3.平均情况事假复杂度

* 定义：用代码在所有情况下执行的次数的加权平均值表示。为了更好地表示平均情况下的复杂度。平均时间复杂度的全称应该叫**加权平均时间复杂度**或者**期望时间复杂度**。

* 分析方法：代码在不同情况下复杂度出现量级差别，则用代码所有可能情况下执行次数的加权平均值表示。

* 使用场景：实际上，在大多数情况下，我们并不需要区分最好、最坏、平均情况时间复杂度三种情况。很多时候我们使用一个复杂度就可以满足需求了。**只有同一块代码在不同的情况下，时间复杂度有量级的差距**，我们才会使用者三种复杂度表示方法来区分。

### 4.均摊时间复杂度

* 定义：在代码执行的所有复杂度情况中绝大部分是低级别的复杂度，个别情况是高级别复杂度且发生具有时序关系时，可以将个别高级别复杂度均摊到低级别复杂度上。基本上均摊结果就等于低级别复杂度。**均摊时间复杂度就是一种特殊的平均时间复杂度**。

* 使用场景：

  * 1.大部分情况下时间复杂度位比较低，是相同的；而在个别情况下复杂度比较高。

  * 2.较低复杂度和较高复杂的出现是非常有规律的，而且存在前后连贯的时序关系。

    在以上场景下我们应该使用**摊还分析法**来分析摊还时间复杂度，就是将复杂度较高的操作所费的时间分摊到复杂的较小的操作，进而分析均摊时间复杂度。


### 5.课后习题

* 题目：利用今天所学的四种复杂度分析方法分析一下下面的add()函数的时间复杂的？

  ```c
  // 全局变量，大小为 10 的数组 array，长度 len，下标 i。
  int array[] = new int[10]; 
  int len = 10;
  int i = 0;
  
  // 往数组中添加一个元素
  void add(int element) {
     if (i >= len) { // 数组空间不够了
       // 重新申请一个 2 倍大小的数组空间
       int new_array[] = new int[len*2];
       // 把原来 array 数组中的数据依次 copy 到 new_array
       for (int j = 0; j < len; ++j) {
         new_array[j] = array[j];
       }
       // new_array 复制给 array，array 现在大小就是 2 倍 len 了
       array = new_array;
       len = 2 * len;
     }
     // 将 element 放到下标为 i 的位置，下标 i 加一
     array[i] = element;
     ++i;
  }
  ```

* 解答：

  * 答案一：

    当i < len时, 即 i = 0,1,2,...,n-1的时候，for循环不走，所以这n次的时间复杂度都是O(1);
    当i >= len时, 即 i = n的时候，for循环进行数组的copy，所以只有这1次的时间复杂度是O(n);
    由此可知:
    该算法的最好情况时间复杂度(best case time complexity)为O(1);
    最坏情况时间复杂度(worst case time complexity)为O(n);
    平均情况时间复杂度(average case time complexity),
    第一种计算方式: (1+1+...+1+n)/(n+1) = 2n/(n+1) 【注: 式子中1+1+...+1中有n个1】,所以平均复杂度为O(1);
    第二种计算方式(加权平均法，又称期望): 1\*(1/n+1)+1\*(1/n+1)+...+1\*(1/n+1)+n\*(1/(n+1))=1，所以加权平均时间复杂度为O(1);
    第三种计算方式(均摊时间复杂度): 前n个操作复杂度都是O(1)，第n+1次操作的复杂度是O(n)，所以把最后一次的复杂度分摊到前n次上，那么均摊下来每次操作的复杂度为O(1)

  * 答案二：

    1. 最好情况时间复杂度为 O(1)
    2. 最坏情况分析： 
      最坏情况代码执行的次数跟每次数组的长度有关
      第1次调用insert的执行的次数为 n ,
      第2次调用insert的执行的次数为 2n ,
      第3次调用insert的执行的次数为 2^2 * n 
      第k次调用insert的执行的次数为 2^(k-1) * n 
      最坏时间复杂度为 O(n)。
    3. 平均情况分析
      当每次遇到最坏情况时数组会进行2倍扩容，原数组被导入新数组，虽然数组的长度变大了，但是插入操作落在的区间的长度是一样的，分别是0~len-1, len~(2len-1),....；
      插入的情况仍是len+1种：0~len-1和插满之后的O(len)；**所以每次插入的概率是：p= 1/len+1**，
      最后求出加权平均时间复杂度为 1\*p + 2\*p+ ▪▪▪ + len*p + len * p = O(1) ; 
    4. 均摊时间复杂度 O(1)
      而均摊复杂度由于每次O(len)的出现都跟着len次O(1)，是前后连贯的，因而将O(len)平摊到前len次上，得出平摊复杂度是O(1)


